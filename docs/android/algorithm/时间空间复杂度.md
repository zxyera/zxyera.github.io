# 时间复杂度和空间复杂度

## 时间复杂度

渐进时间复杂度，简称时间复杂度 T(n)。用来衡量程序执行时间，使用大 O 表示，如 O(n)。
$$T(n) = O(f(n))$$
f(n) 表示每行代码执行次数之和的函数。

```kotlin
var i = 0
j = 1
```

上面代码每行的执行次数都是 1，因此它的时间复杂度是 1+1=2，它是一个常量，因此时间复杂度为 $O(1)$

推导时间复杂度的几个原则：

1. 运行时间是常数量级，时间复杂度为 $O(1)$
2. 只保留时间函数中的最高阶项，如 $T(n) = n^3 + n^2$，那么时间复杂度就是$$O(n^3)$$
3. 去除最高阶前面的系数，如 $T(n) = 3n^3 + n^2$，时间复杂度为 $O(n^3)$

n 的大小能影响到算法的执行时间，通常情况下使用趋近无限大的 n 来推导算法的时间复杂度。

场景的时间复杂度有： $O(1)、O(n)、O(log_2n)、O(n^m)、O(2^n)、O(nlog_2n)$等

1. $O(n)$
   ```kotlin
   for(var i = 0; i < n; i++) {
       print(i)
   }
   ```
2. $O(log_2n)$
   ```kotlin
   while(i < n) {
       i = i * 2
   }
   ```
3. $O(n2)$
   ```kotlin
   for (var i = 0; i < n; i++) {
       for (var j = 0; j < n; j++) {
           print(i + j)
       }
   }
   ```

## 空间复杂度

程序在执行过程中所需要占用的内存空间的度量。也用大 O 表示法。
$$S(n) = O(f(n))$$

$f(n)$为算法所占用内存空间的函数

当算法在执行过程中所占用的内存空间恒定不变，那么空间复杂度就是 $O(1)$，如果内存空间随着程序的执行呈正比增长，那么空间复杂度就是 $O(n)$---如一维数组。同样的还有二维数组，那么二维数组的空间复杂度就是 $O(n^2)$

在时间复杂度相同的情况下，空间复杂度越低表示算法越好，而在空间复杂度相同的情况下，时间复杂度越低表示算法越好。在选取算法时需要衡量时间复杂度和空间复杂度的平衡，不能一味地追求其中的一个。
